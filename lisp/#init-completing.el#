;;; init-completing --- completing-read -*- coding: utf-8; lexical-binding: t; -*-

;;; Commentary:
;; My Emacs completing framework setup
;; - selectrum + prescient, the incremental search package, setup
;; - vertico + orderless
;;

;;; Code:

(require-package 'amx)

(use-package consult
  :ensure t
  :defer t
  :config
  ;; this is an option to make
  (setq consult-line-start-from-top nil))

;; provide annotations in minibuffer
(use-package marginalia
  :ensure t
  :defer 1
  :hook (after-init . marginalia-mode))

;; @see https://github.com/raxod502/selectrum
(use-package selectrum
  :disabled
  :ensure t
  :defer t
  :hook (after-init . selectrum-mode)
  :config
  (setq amx-backend 'selectrum)
  (setq selectrum-should-sort nil)
  (setq selectrum-count-style 'current/matches
	selectrum-extend-current-candidate-highlight t)
  (setq-default selectrum-move-default-candidate nil)

  (define-key selectrum-minibuffer-map [C-return] #'selectrum-submit-exact-input)
  (local-require 'selectsel))

;; Vertico seems to lag when dealing with a very long list
;; such as while in describe-functions
(use-package vertico
  :ensure t
  :config
  (local-require 'selectsel)
  (setq amx-backend 'auto)
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args)))
  :init
  ;; Grow and shrink the Vertico minibuffer
  (setq vertico-resize t)
  ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
  ;; (setq vertico-cycle nil)
  (vertico-mode 1))

(setq enable-recursive-minibuffers t)

(use-package corfu
  :disabled
  :ensure t
  :config
  :init
  (setq corfu-auto t)
  (setq corfu-auto-delay 0.1)
  (corfu-global-mode 1))

(setq completion-cycle-threshold 3)

(autoload 'pyim-cregexp-build "pyim")

(defvar my/enable-pinyin-in-completing-read nil)

;; TODO: rename this to enable
(defun toggle-pinyin-in-completing-read ()
  "Toggle variable `my/enable-pinyin-in-completing-read'."
  (interactive)
  (message "pinyin in completing read: %s"
           (setq my/enable-pinyin-in-completing-read
                 (not my/enable-pinyin-in-completing-read))))

(add-hook 'selectrum-candidate-selected-hook
          (defun completing/disable-pinyin-after-exit (_cand)
            (setq my/enable-pinyin-in-completing-read nil)))

(use-package orderless
  :defer t
  :ensure t
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion))))
  :config
  (setq orderless-matching-styles
        '(orderless-literal
          orderless-regexp
          match-flex-or-pinyin))
  (defun match-flex-or-pinyin (str)
    "Add pinyin search support to orderless, builds STR.
Otherwise, uses orderless-flex. Avoiding computation lag."
    ;; orderless-regexp
    ;; Needs to be careful for the regexp to get too long.
    (if my/enable-pinyin-in-completing-read
        (let ((pinyin-regexp (pyim-cregexp-build str)))
          (if (<= (length pinyin-regexp) 2000)
              pinyin-regexp
            (message "%s is too long for pinyin" (length pinyin-regexp))
            str))
      (orderless-flex str))))

(use-package icomplete
  :disabled
  :ensure nil
  :config
  (setq amx-backend 'auto)
  :init
  (add-hook 'after-init-hook 'fido-mode)
  (add-hook 'after-init-hook 'fido-vertical-mode))

;; (grep-apply-setting
;;  'grep-find-command
;;  '("rg -n -H --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 27))

(defun completing--replace-search (search)
  "Replace the SEARCH with `read-string'."
  (if (string-empty-p search)
      (message "enter some text first!")
    (let ((to-string (read-string "To: "))
          (buf (seq-find (lambda (x) (not (minibufferp x)))
			 (buffer-list))))
      (with-selected-window (get-buffer-window buf)
        (with-current-buffer buf
	  (query-replace-regexp search to-string)
	  (exit-minibuffer))))))

(defun completing-swiper ()
  "My version of swiper."
  (interactive)
  ;; (selectsel-swiper (util/thing-at-point/deselect))
  ;; (let ((selectrum-minibuffer-map
  ;;        (let ((map (make-sparse-keymap)))
  ;;          (set-keymap-parent map selectrum-minibuffer-map)
  ;;          (define-key map [?\M-q]
  ;;            (lambda ()
  ;;              (interactive)
  ;;              (completing--replace-search (car consult--line-history))))
  ;;          map))))
  (consult-line (util/thing-at-point/deselect))
  (selectsel--yank-search (car consult--line-history)))

(defun completing-ripgrep (arg)
  "My version of ripgrep.
ARG can be used to control the behaviour of `consult-ripgrep'
A single `universal-argument' can disable preview.
Two `universal-argument' to change read a different directory to ripgrep."
  (interactive "P")
  (require 'consult)
  (let ((init-input (util/thing-at-point/deselect))
        ;; back two variables
        (consult-preview-key consult-preview-key)
        (default-directory default-directory))
    (when (consp arg)
      (cond ((equal arg '(4))
             (setq consult-preview-key nil))
            ((equal arg '(16))
             (setq default-directory
                   (read-file-name
                    "Directory: "
                    default-directory nil nil nil #'file-directory-p)))))
    (consult-ripgrep default-directory init-input))
  (selectsel--yank-search (car consult--grep-history)))

(defun completing-ripgrep-backups ()
  "Ripgrep search the backups of this current buffer file."
  (interactive)
  (if (find-backup-file-name buffer-file-name)
      (let* ((backup-file (make-backup-file-name-1 buffer-file-name))
             (initial "")
             (command (format "%s -g \"%s*\""
                              consult-ripgrep-command
                              (replace-regexp-in-string
                               "\!" "\\\\!"
                               (file-name-nondirectory backup-file)))))
        (message command)
        (consult--grep "Ripgrep" command
                       (file-name-directory backup-file)
                       initial))
    (message "no backup files for %s to search" buffer-name)))
;;

(defun my/git-recent-files ()
  "Get files in my recent git commits."
  (let* ((default-directory (my/git-root-dir))
         ;; two weeks is a sprint, minus weekend and days for sprint review and test
         (cmd (format "git --no-pager log --name-only --since=\"30 days ago\" --pretty=format: | sort | uniq | awk NF"))
         (lines (util/shell-command-to-lines cmd)))
    (mapcar #'abbreviate-file-name lines)))

(defun completing-imenu-comments ()
  "Imenu display comments."
  (interactive)
  (let ((imenu-generic-expression
         `(("Comments" ,(format "^%s+\\(.*\\)$" comment-start) 1))))
    (completing-imenu)))

(defalias 'completing-imenu 'consult-imenu)

(defun selectrum-org-headlines-candidates (&optional scope)
  "See `org-map-entries' for the definition of SCOPE."
  (org-map-entries
   (lambda ()
     (cl-destructuring-bind (level1 level2 todo priority text tags)
	 (org-heading-components)
       (let ((headline
	      (mapconcat ;; concat list
	       'identity
	       (delq ;; remove nil
                nil
		(list (make-string level1 ?*)
		      ;; (and priority (format "[#%c]" priority))
		      (mapconcat 'identity
				 (append
				  (org-get-outline-path)
				  (list ""))
				 "/")
		      todo
		      text
		      tags))
	       " ")))
	 (propertize headline
		     'selectrum-candidate-display-prefix
		     (propertize
		      (format "%s:" (file-name-nondirectory buffer-file-name))
		      'face 'completions-annotations)
		     'marker (point-marker)))))
   nil
   (or scope 'agenda)))

(defun selectrum-org-agenda-headlines ()
  "Choose from headers of `org-mode' files in the agenda."
  (interactive)
  (when-let* ((headline (selectrum--read
                         "Org headline: "
			 (selectrum-org-headlines-candidates 'agenda))))
    (let ((m (get-text-property 0 'marker headline)))
      (switch-to-buffer (marker-buffer m))
      (goto-char (marker-position m)))))

(defun keymap-completion-candidates (keymap)
  (cl-loop for (key . bind) in (cdr keymap)
           ;; take care of 'remap
           collect
           (cond ((numberp key) (key-description (vector key)))
                 ((symbolp key) (if (eq key 'remap)
                                    (format "%s %s" key bind)
                                  (format "%s" key)))
                 (T key))
           into keys
           ;; take care of 'keymap
           collect (if (and (listp bind) (symbolp (car bind)))
                       (if (eq (car bind) 'keymap)
                           (mapcar (lambda (str)) (keymap-completion-candidates (cdr bind)))
                         (error "unexpected %s" bind))
                     bind)
           into binds
           finally (return (cl-mapcar #'cons keys binds))))

;; (format "%s" (keymap-completion-candidates evil-insert-state-map))

;; selectrum evil mark
;; @see https://github.com/raxod502/selectrum/wiki/Useful-Commands#evil-marks

(provide 'init-completing)
;;; init-completing ends here
